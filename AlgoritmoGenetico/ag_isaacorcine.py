# -*- coding: utf-8 -*-
"""AG_IsaacOrcine_Luis Felipe.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pdMl_7i6Hs-usU7gkHLUdz5cbULZUpwg
"""

import numpy as np
import random

"""Função objetivo"""

def funcao_objetivo(x):
    x_decimal = int(''.join(x), 2)
    x_scaled = -10 + x_decimal * (20 / (2 ** len(x) - 1))
    return x_scaled ** 2 - 3 * x_scaled + 4

"""Função para calcular o fitness"""

def calcular_fitness(populacao):
    fitness = [funcao_objetivo(individuo) for individuo in populacao]
    return fitness

"""Conversão de binário para decimal"""

def binario_para_decimal_ajustado(individuo):
    x_decimal = int(''.join(individuo), 2)
    x_scaled = -10 + x_decimal * (20 / (2 ** len(individuo) - 1))
    return x_scaled

"""Inicialização da população com valores no intervalo"""

def inicializar_populacao(num_individuos, num_bits):
    populacao = []
    for _ in range(num_individuos):
        decimal_x = gerar_valor_no_intervalo()
        bin_x = bin(int((decimal_x + 10) / 20 * (2 ** num_bits)))[2:].zfill(num_bits)
        populacao.append(list(bin_x))
    return populacao

"""Mutação"""

def mutacao(individuo, taxa_mutacao):
    for i in range(len(individuo)):
        if random.random() < taxa_mutacao:
            individuo[i] = '0' if individuo[i] == '1' else '1'
    return individuo

"""Crossover"""

def crossover(pai, mae, taxa_crossover):
    if random.random() < taxa_crossover:
        ponto_crossover = random.randint(1, len(pai) - 1)
        filho_1 = pai[:ponto_crossover] + mae[ponto_crossover:]
        filho_2 = mae[:ponto_crossover] + pai[ponto_crossover:]
        return filho_1, filho_2
    return pai, mae

"""Seleção por torneio"""

def selecao_por_torneio(populacao, num_participantes):
    participantes = random.sample(populacao, num_participantes)
    return max(participantes, key=funcao_objetivo)

"""Ajuste de limites"""

def ajustar_limites(valor):
    if valor >= 10:
        return 10
    elif valor <= -10:
        return -10
    return valor

"""Geração de valores no intervalo"""

def gerar_valor_no_intervalo():
    return random.uniform(-10, 10)

"""Algoritmo Genético"""

def algoritmo_genetico(num_individuos, num_geracoes, taxa_mutacao, taxa_crossover, num_bits):
    populacao = inicializar_populacao(num_individuos, num_bits)

    for geracao in range(num_geracoes):
        fitness = calcular_fitness(populacao)
        melhores_individuos = [(funcao_objetivo(individuo), binario_para_decimal_ajustado(individuo)) for individuo in populacao]
        melhor_individuo = max(melhores_individuos, key=lambda x: x[0])

        print("\nGeração:", geracao + 1)
        print("Melhor Indivíduo Encontrado (X):", ajustar_limites(melhor_individuo[1]))
        print("Valor Máximo da Função Objetivo:", melhor_individuo[0])

        print("População (em decimal):")
        populacao_decimal = [binario_para_decimal_ajustado(individuo) for individuo in populacao]
        print(populacao_decimal)

        nova_populacao = []

        while len(nova_populacao) < num_individuos:
            pai_1 = selecao_por_torneio(populacao, 3)
            pai_2 = selecao_por_torneio(populacao, 3)
            filho_1, filho_2 = crossover(pai_1, pai_2, taxa_crossover)
            filho_1 = mutacao(filho_1, taxa_mutacao)
            filho_2 = mutacao(filho_2, taxa_mutacao)
            nova_populacao.extend([filho_1, filho_2])

        populacao = nova_populacao

    melhores_individuos = [(funcao_objetivo(individuo), binario_para_decimal_ajustado(individuo)) for individuo in populacao]
    melhor_individuo = max(melhores_individuos, key=lambda x: x[0])

    print("\nMelhor Indivíduo Encontrado (X):", ajustar_limites(melhor_individuo[1]))
    print("Valor Máximo da Função Objetivo:", melhor_individuo[0])

"""Parâmetros configuráveis"""

num_individuos = 4
num_geracoes = 5
taxa_mutacao = 0.01
taxa_crossover = 0.7
num_bits = 8

"""Execução do Algoritmo Genético"""

algoritmo_genetico(num_individuos, num_geracoes, taxa_mutacao, taxa_crossover, num_bits)